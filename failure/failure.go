// Tideland Go Trace - Failure
//
// Copyright (C) 2020 Frank Mueller / Tideland / Oldenburg / Germany
//
// All rights reserved. Use of this source code is governed
// by the new BSD license.

package failure // import "tideland.dev/go/trace/failure"

//--------------------
// IMPORTS
//--------------------

import (
	"fmt"
	"strings"

	"tideland.dev/go/trace/location"
)

//--------------------
// FAILURE
//--------------------

// failure encapsulates an error.
type failure struct {
	err      error
	infos    []*InfoBag
	msg      string
	hereCode string
	hereID   string
}

// newFailure creates an initialized failure.
func newFailure(err error, msg string, args ...interface{}) *failure {
	var infos []*InfoBag
	for _, arg := range args {
		if info, ok := arg.(*InfoBag); ok {
			infos = append(infos, info)
		}
	}
	return &failure{
		err:      err,
		infos:    infos,
		msg:      fmt.Sprintf(msg, args...),
		hereCode: location.At(2).Code("E"),
		hereID:   location.At(2).ID,
	}
}

// Unwrap returns a wrapped error.
func (f *failure) Unwrap() error {
	return f.err
}

// Error implements the error interface.
func (f *failure) Error() string {
	if f.err != nil {
		return fmt.Sprintf("[%s] %s: %v", f.hereCode, f.msg, f.err)
	}
	return fmt.Sprintf("[%s] %s", f.hereCode, f.msg)
}

//--------------------
// ERROR COLLECTION
//--------------------

// errorCollection bundles multiple errors.
type errorCollection struct {
	errs []error
}

// Error implements the error interface.
func (ec *errorCollection) Error() string {
	errMsgs := make([]string, len(ec.errs))
	for i, err := range ec.errs {
		errMsgs[i] = err.Error()
	}
	return strings.Join(errMsgs, " :: ")
}

//--------------------
// ERROR FUNCTIONS
//--------------------

// New creates an error with the given code.
func New(msg string, args ...interface{}) error {
	return newFailure(nil, msg, args...)
}

// Annotate creates an error wrapping another one together with a
// a code. If the passed one is nil, Annotate() also returns nil.
func Annotate(err error, msg string, args ...interface{}) error {
	if err == nil {
		return nil
	}
	return newFailure(err, msg, args...)
}

// First checks the existing error for nil. If not it will be returned,
// otherwise the setting one. So usage is myStruct.err = failure.First(myStruct.err, newErr).
func First(existing, setting error) error {
	if existing != nil {
		return existing
	}
	return setting
}

// Collect collects multiple errors into one. If there's none, nil
// will be returned.
func Collect(errs ...error) error {
	// Drop nil errors.
	var nnerrs []error
	for _, err := range errs {
		if err != nil {
			nnerrs = append(nnerrs, err)
		}
	}
	// Check if still errors exist.
	switch len(nnerrs) {
	case 0:
		return nil
	case 1:
		return nnerrs[0]
	default:
		return &errorCollection{
			errs: nnerrs,
		}
	}
}

// IsValid returns true if it is a valid error generated by
// this package.
func IsValid(err error) bool {
	_, ok := err.(*failure)
	return ok
}

// Contains returns true if the given error contains a given string.
func Contains(err error, substr string) bool {
	if err == nil {
		return false
	}
	return strings.Contains(err.Error(), substr)
}

// Annotated returns the possibly annotated error. In case of
// a different error an invalid type error is returned.
func Annotated(err error) error {
	if uerr, ok := err.(interface {
		Unwrap() error
	}); ok {
		return uerr.Unwrap()
	}
	return Annotate(err, "passed error has invalid type")
}

// Location returns the package and the file name as well as the line
// number of the error.
func Location(err error) (string, error) {
	if f, ok := err.(*failure); ok {
		return f.hereID, nil
	}
	return "", Annotate(err, "passed error has invalid type")
}

// Stack returns a slice of errors down to the lowest
// not annotated error.
func Stack(err error) []error {
	if uerr, ok := err.(interface {
		Unwrap() error
	}); ok {
		return append([]error{err}, Stack(uerr.Unwrap())...)
	}
	return []error{err}
}

// All returns a slice of errors in case of collected errors.
func All(err error) []error {
	if ec, ok := err.(*errorCollection); ok {
		all := make([]error, len(ec.errs))
		copy(all, ec.errs)
		return all
	}
	return []error{err}
}

// DoAll iterates the passed function over all stacked
// or collected errors or simply the one that's passed.
func DoAll(err error, errF func(error)) {
	switch terr := err.(type) {
	case *failure:
		for _, serr := range Stack(err) {
			errF(serr)
		}
	case *errorCollection:
		for _, aerr := range All(err) {
			errF(aerr)
		}
	default:
		errF(terr)
	}
}

// AllInfoBags returns all InfoBags an error created by this
// package potentially contains.
func AllInfoBags(err error) []*InfoBag {
	var infos []*InfoBag
	if IsValid(err) {
		f := err.(*failure)
		infos = make([]*InfoBag, len(f.infos))
		copy(infos, f.infos)
	}
	return infos
}

// DoAllInfoBags processes all InfoBags an error created by this
// package potentially contains.
func DoAllInfoBags(err error, ibF func(*InfoBag)) {
	if IsValid(err) {
		f := err.(*failure)
		for _, info := range f.infos {
			ibF(info)
		}
	}
}

// EOF
